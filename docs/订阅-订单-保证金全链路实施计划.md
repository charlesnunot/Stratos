# 订阅-订单-保证金全链路实施计划

## 一、项目概述

### 1.1 目标
基于《订阅-订单-保证金全链路分析报告》，修复三个关键缺口，完善保证金生命周期管理，实现从订单完成/取消到保证金自动恢复，以及保证金退款流程的完整闭环。

### 1.2 实施范围
- **缺口1**：订单完成/取消后自动恢复接单功能
- **缺口2**：保证金 lot 状态从 `held` 自动流转到 `refundable`
- **缺口3**：保证金退款申请与处理流程（`refundable` → `refunded`）

### 1.3 预期成果
- 订单完成或取消后，系统自动检查并恢复卖家接单功能
- 保证金在满足条件后自动变为可退款状态
- 卖家可以申请保证金退款，平台执行退款流程

---

## 二、任务分解与优先级

### 2.1 任务清单

| 任务ID | 任务名称 | 优先级 | 预估工时 | 依赖关系 |
|--------|---------|--------|---------|---------|
| T1 | 修复订单完成后的自动恢复接单 | P0 | 4h | - |
| T2 | 修复订单取消后的自动恢复接单 | P0 | 4h | - |
| T3 | 实现 held → refundable 状态流转（数据库函数） | P1 | 6h | - |
| T4 | 创建保证金状态检查 cron 任务 | P1 | 4h | T3 |
| T5 | 实现保证金退款申请 API | P1 | 8h | T3 |
| T6 | 实现保证金退款处理逻辑 | P1 | 8h | T5 |
| T7 | 创建保证金退款前端页面 | P2 | 6h | T5 |
| T8 | 测试与文档更新 | P0 | 6h | T1-T7 |

**优先级说明**：
- **P0**：核心功能，必须实现
- **P1**：重要功能，建议实现
- **P2**：增强功能，可选实现

---

## 三、详细实施步骤

### 阶段一：修复订单完成/取消后的自动恢复接单（P0）

#### 任务 T1：修复订单完成后的自动恢复接单

**目标**：在买家确认收货后，自动检查并恢复卖家接单功能。

**涉及文件**：
- `src/app/api/orders/[id]/confirm-receipt/route.ts`
- `src/lib/orders/auto-recovery.ts`（已存在，需使用）

**实施步骤**：

1. **修改 `confirm-receipt/route.ts`**
   - 在订单状态更新为 `completed` 之后
   - 调用 `checkRecoveryOnOrderCompletion(orderId, supabaseAdmin)`
   - 确保错误处理不影响主流程（使用 try-catch）

2. **验证逻辑**
   - `checkRecoveryOnOrderCompletion` 已存在，内部调用 `checkAutoRecovery`
   - `checkAutoRecovery` 会检查 `unfilled <= tier` 并调用 `enableSellerPayment`

**代码修改示例**：
```typescript
// 在 confirm-receipt/route.ts 中，订单更新成功后添加：
import { checkRecoveryOnOrderCompletion } from '@/lib/orders/auto-recovery'

// 在订单状态更新后
if (order.seller_id) {
  // 检查并恢复接单（异步，不阻塞）
  checkRecoveryOnOrderCompletion(order.id, supabaseAdmin).catch((error) => {
    console.error('[confirm-receipt] Auto-recovery check failed:', error)
  })
}
```

**测试要点**：
- 订单完成后，unfilled 下降至档位以下时，`payment_enabled` 应自动恢复
- 订单完成后，unfilled 仍高于档位时，不应恢复
- 错误不应影响订单完成流程

---

#### 任务 T2：修复订单取消后的自动恢复接单

**目标**：在订单取消后，自动检查并恢复卖家接单功能。

**涉及文件**：
- `src/app/api/orders/[id]/cancel/route.ts`
- `src/lib/deposits/payment-control.ts`（`checkAutoRecovery`）

**实施步骤**：

1. **修改 `cancel/route.ts`**
   - 在订单状态更新为 `cancelled` 且退款处理完成后
   - 对受影响卖家调用 `checkAutoRecovery(sellerId, supabaseAdmin)`
   - 注意：订单取消可能涉及多个卖家（多商品订单），需要遍历所有卖家

2. **处理多卖家场景**
   - 如果订单包含多个卖家的商品，需要对每个卖家分别调用 `checkAutoRecovery`
   - 从 `order_items` 表获取所有 `seller_id`，去重后逐个检查

**代码修改示例**：
```typescript
// 在 cancel/route.ts 中，订单取消成功后添加：
import { checkAutoRecovery } from '@/lib/deposits/payment-control'

// 获取订单涉及的所有卖家
const { data: orderItems } = await supabaseAdmin
  .from('order_items')
  .select('seller_id')
  .eq('order_id', orderId)

const sellerIds = new Set<string>()
if (orderItems && orderItems.length > 0) {
  orderItems.forEach(item => {
    if (item.seller_id) sellerIds.add(item.seller_id)
  })
} else if (order.seller_id) {
  sellerIds.add(order.seller_id)
}

// 对每个卖家检查自动恢复
for (const sellerId of sellerIds) {
  checkAutoRecovery(sellerId, supabaseAdmin).catch((error) => {
    console.error(`[cancel] Auto-recovery check failed for seller ${sellerId}:`, error)
  })
}
```

**测试要点**：
- 单商品订单取消后，卖家接单功能应自动恢复（如果满足条件）
- 多商品订单取消后，所有相关卖家都应检查恢复
- 退款失败时，仍应检查恢复（因为订单已取消，unfilled 已下降）

---

### 阶段二：实现 held → refundable 状态流转（P1）

#### 任务 T3：实现 held → refundable 状态流转（数据库函数）

**目标**：创建数据库函数，检查并更新符合条件的 lot 状态为 `refundable`。

**涉及文件**：
- 新建 migration：`supabase/migrations/138_update_deposit_lots_to_refundable.sql`

**实施步骤**：

1. **创建数据库函数 `update_deposit_lots_to_refundable`**
   - 查询所有 `status='held'` 的 lot
   - 对每个 lot 调用 `check_deposit_refundable(lot_id)`
   - 如果返回 `true`，更新 lot：
     - `status = 'refundable'`
     - `refundable_at = NOW() + INTERVAL '3 days'`（3个工作日，简化实现为3个自然日）
   - 返回更新的 lot 数量

2. **考虑工作日计算**
   - 简化版：使用 `NOW() + INTERVAL '3 days'`
   - 完整版：实现工作日计算函数（排除周末和节假日）
   - **建议**：先实现简化版，后续可优化

3. **函数签名**：
```sql
CREATE OR REPLACE FUNCTION update_deposit_lots_to_refundable()
RETURNS TABLE (
  updated_count INTEGER,
  updated_lot_ids UUID[]
) AS $$
```

**Migration 文件内容**：
```sql
-- Function to update deposit lots from 'held' to 'refundable'
-- Called by cron job to check and update lot status
CREATE OR REPLACE FUNCTION update_deposit_lots_to_refundable()
RETURNS TABLE (
  updated_count INTEGER,
  updated_lot_ids UUID[]
) AS $$
DECLARE
  v_lot RECORD;
  v_updated_count INTEGER := 0;
  v_updated_lot_ids UUID[] := ARRAY[]::UUID[];
BEGIN
  -- Loop through all 'held' lots
  FOR v_lot IN
    SELECT id, seller_id
    FROM seller_deposit_lots
    WHERE status = 'held'
  LOOP
    -- Check if lot can be refunded
    IF check_deposit_refundable(v_lot.id) THEN
      -- Update lot to refundable
      UPDATE seller_deposit_lots
      SET 
        status = 'refundable',
        refundable_at = NOW() + INTERVAL '3 days',
        updated_at = NOW()
      WHERE id = v_lot.id;
      
      v_updated_count := v_updated_count + 1;
      v_updated_lot_ids := array_append(v_updated_lot_ids, v_lot.id);
    END IF;
  END LOOP;
  
  RETURN QUERY SELECT v_updated_count, v_updated_lot_ids;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**测试要点**：
- 函数应正确识别满足条件的 lot
- 只更新 `status='held'` 的 lot
- 正确设置 `refundable_at` 时间戳

---

#### 任务 T4：创建保证金状态检查 cron 任务

**目标**：创建定时任务，定期检查并更新保证金 lot 状态。

**涉及文件**：
- 新建：`src/app/api/cron/update-deposit-lots-status/route.ts`
- 修改：`vercel.json`（添加 cron 配置）

**实施步骤**：

1. **创建 cron API 路由**
   - 参考现有 cron 任务结构（如 `subscription-lifecycle/route.ts`）
   - 验证 `CRON_SECRET`
   - 调用数据库函数 `update_deposit_lots_to_refundable()`
   - 记录执行日志

2. **配置 Vercel Cron**
   - 在 `vercel.json` 中添加新任务
   - 建议频率：每天凌晨 4:00（避免与其他任务冲突）

**代码示例**：
```typescript
// src/app/api/cron/update-deposit-lots-status/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    // Verify cron secret
    const authHeader = request.headers.get('authorization')
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { createClient: createAdminClient } = await import('@supabase/supabase-js')
    const supabaseAdmin = createAdminClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false,
        },
      }
    )

    const startTime = Date.now()
    console.log('[Cron] Starting deposit lots status update at', new Date().toISOString())
    
    const { data, error } = await supabaseAdmin.rpc('update_deposit_lots_to_refundable')

    if (error) {
      console.error('[Cron] Error updating deposit lots:', error)
      return NextResponse.json(
        { error: error.message || 'Failed to update deposit lots' },
        { status: 500 }
      )
    }

    const duration = Date.now() - startTime
    const result = data?.[0] || { updated_count: 0, updated_lot_ids: [] }

    console.log('[Cron] Deposit lots status update completed in', duration, 'ms')
    console.log('[Cron] Updated lots:', result.updated_count)

    return NextResponse.json({
      success: true,
      updated_count: result.updated_count,
      updated_lot_ids: result.updated_lot_ids,
      execution_time_ms: duration,
    })
  } catch (error: any) {
    console.error('[Cron] Deposit lots status update error:', error)
    return NextResponse.json(
      { error: error.message || 'Failed to update deposit lots status' },
      { status: 500 }
    )
  }
}
```

**Vercel Cron 配置**：
```json
{
  "crons": [
    // ... 现有任务
    {
      "path": "/api/cron/update-deposit-lots-status",
      "schedule": "0 4 * * *"
    }
  ]
}
```

**测试要点**：
- Cron 任务应正确调用数据库函数
- 验证 `CRON_SECRET` 保护
- 记录执行结果和日志

---

### 阶段三：实现保证金退款流程（P1）

#### 任务 T5：实现保证金退款申请 API

**目标**：创建 API，允许卖家申请保证金退款。

**涉及文件**：
- 新建：`src/app/api/deposits/[lotId]/request-refund/route.ts`

**实施步骤**：

1. **创建退款申请 API**
   - 路径：`POST /api/deposits/[lotId]/request-refund`
   - 验证用户身份和 lot 所有权
   - 验证 lot 状态为 `refundable` 且 `refundable_at <= NOW()`
   - 更新 lot 状态为 `refunding`
   - 记录退款申请信息

2. **验证逻辑**：
   - 用户必须是 lot 的 `seller_id`
   - `status` 必须为 `refundable`
   - `refundable_at` 必须已到期（`<= NOW()`）
   - 不能有正在处理中的退款（`status='refunding'`）

3. **返回信息**：
   - 退款金额（扣除手续费后）
   - 预计退款方式
   - 退款处理时间

**API 实现示例**：
```typescript
// src/app/api/deposits/[lotId]/request-refund/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function POST(
  request: NextRequest,
  { params }: { params: { lotId: string } }
) {
  try {
    const supabase = await createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { createClient: createAdminClient } = await import('@supabase/supabase-js')
    const supabaseAdmin = createAdminClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false,
        },
      }
    )

    // Get lot details
    const { data: lot, error: lotError } = await supabaseAdmin
      .from('seller_deposit_lots')
      .select('*')
      .eq('id', params.lotId)
      .single()

    if (lotError || !lot) {
      return NextResponse.json(
        { error: 'Deposit lot not found' },
        { status: 404 }
      )
    }

    // Verify ownership
    if (lot.seller_id !== user.id) {
      return NextResponse.json(
        { error: 'Forbidden' },
        { status: 403 }
      )
    }

    // Verify status
    if (lot.status !== 'refundable') {
      return NextResponse.json(
        { error: `Deposit lot is not refundable. Current status: ${lot.status}` },
        { status: 400 }
      )
    }

    // Verify refundable_at
    if (lot.refundable_at && new Date(lot.refundable_at) > new Date()) {
      return NextResponse.json(
        { error: 'Deposit is not yet refundable. Please wait until the refundable date.' },
        { status: 400 }
      )
    }

    // Update lot status to 'refunding'
    const { error: updateError } = await supabaseAdmin
      .from('seller_deposit_lots')
      .update({
        status: 'refunding',
        updated_at: new Date().toISOString(),
      })
      .eq('id', params.lotId)

    if (updateError) {
      console.error('[request-refund] Error updating lot:', updateError)
      return NextResponse.json(
        { error: 'Failed to request refund' },
        { status: 500 }
      )
    }

    // Send notification
    await supabaseAdmin.from('notifications').insert({
      user_id: user.id,
      type: 'deposit',
      title: '保证金退款申请已提交',
      content: `您的保证金退款申请已提交，金额为 ${lot.required_amount} ${lot.currency}。我们将在3-5个工作日内处理。`,
      related_id: lot.id,
      related_type: 'deposit_lot',
      link: `/seller/deposit`,
    }).catch((err) => {
      console.error('[request-refund] Failed to send notification:', err)
    })

    return NextResponse.json({
      success: true,
      message: 'Refund request submitted',
      lot_id: lot.id,
      amount: lot.required_amount,
      currency: lot.currency,
    })
  } catch (error: any) {
    console.error('[request-refund] Error:', error)
    return NextResponse.json(
      { error: error.message || 'Failed to request refund' },
      { status: 500 }
    )
  }
}
```

**测试要点**：
- 只有 lot 所有者可以申请退款
- 只有 `refundable` 状态的 lot 可以申请
- `refundable_at` 必须已到期
- 状态应正确更新为 `refunding`

---

#### 任务 T6：实现保证金退款处理逻辑

**目标**：创建后台处理逻辑，执行保证金退款。

**涉及文件**：
- 新建：`src/lib/deposits/process-deposit-refund.ts`
- 新建：`src/app/api/admin/deposits/[lotId]/process-refund/route.ts`（管理员 API）

**实施步骤**：

1. **创建退款处理服务** (`process-deposit-refund.ts`)
   - 接收 lot ID
   - 获取 lot 信息（状态、金额、支付方式等）
   - 根据原始支付方式执行退款：
     - Stripe：使用 Stripe API 退款
     - PayPal：使用 PayPal API 退款
     - 其他方式：标记为需手动处理
   - 更新 lot 状态为 `refunded`
   - 记录退款交易信息

2. **创建管理员 API**（可选，用于手动触发）
   - 路径：`POST /api/admin/deposits/[lotId]/process-refund`
   - 需要管理员权限
   - 调用退款处理服务

3. **集成到现有退款流程**
   - 可以复用 `src/lib/payments/process-refund.ts` 的部分逻辑
   - 但保证金退款是退给卖家，不是买家

**退款处理服务示例**：
```typescript
// src/lib/deposits/process-deposit-refund.ts
import { SupabaseClient } from '@supabase/supabase-js'
import Stripe from 'stripe'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia',
})

export interface ProcessDepositRefundParams {
  lotId: string
  supabaseAdmin: SupabaseClient
}

export async function processDepositRefund({
  lotId,
  supabaseAdmin,
}: ProcessDepositRefundParams): Promise<{
  success: boolean
  error?: string
  transactionId?: string
}> {
  try {
    // Get lot details
    const { data: lot, error: lotError } = await supabaseAdmin
      .from('seller_deposit_lots')
      .select('*')
      .eq('id', lotId)
      .single()

    if (lotError || !lot) {
      return { success: false, error: 'Deposit lot not found' }
    }

    if (lot.status !== 'refunding') {
      return { success: false, error: `Lot is not in refunding status. Current: ${lot.status}` }
    }

    // Get payment transaction
    let refundTransactionId: string | undefined
    let refundFeeAmount = 0
    let refundedAmount = lot.required_amount

    // Process refund based on payment method
    if (lot.payment_provider === 'stripe' && lot.payment_session_id) {
      // Get original payment transaction
      const { data: paymentTx } = await supabaseAdmin
        .from('payment_transactions')
        .select('*')
        .eq('id', lot.payment_session_id)
        .single()

      if (paymentTx?.stripe_payment_intent_id) {
        // Calculate refund amount (deduct Stripe fee)
        // Stripe fee is typically 2.9% + $0.30
        const stripeFee = lot.required_amount * 0.029 + 0.30
        refundFeeAmount = Math.min(stripeFee, lot.required_amount)
        refundedAmount = lot.required_amount - refundFeeAmount

        // Create Stripe refund
        const refund = await stripe.refunds.create({
          payment_intent: paymentTx.stripe_payment_intent_id,
          amount: Math.round(refundedAmount * 100), // Convert to cents
        })

        // Create refund transaction record
        const { data: refundTx, error: txError } = await supabaseAdmin
          .from('payment_transactions')
          .insert({
            user_id: lot.seller_id,
            transaction_type: 'deposit_refund',
            amount: refundedAmount,
            currency: lot.currency,
            payment_method: 'stripe',
            stripe_refund_id: refund.id,
            status: 'completed',
            metadata: {
              deposit_lot_id: lot.id,
              original_amount: lot.required_amount,
              refund_fee: refundFeeAmount,
            },
          })
          .select()
          .single()

        if (txError) {
          console.error('Failed to create refund transaction:', txError)
        } else {
          refundTransactionId = refundTx.id
        }
      }
    } else {
      // For non-Stripe payments, mark as manual processing required
      return {
        success: false,
        error: `Manual refund processing required for payment method: ${lot.payment_provider}`,
      }
    }

    // Update lot status
    const { error: updateError } = await supabaseAdmin
      .from('seller_deposit_lots')
      .update({
        status: 'refunded',
        refund_fee_amount: refundFeeAmount,
        refunded_amount: refundedAmount,
        refund_transaction_id: refundTransactionId,
        updated_at: new Date().toISOString(),
      })
      .eq('id', lotId)

    if (updateError) {
      console.error('Failed to update lot status:', updateError)
      return { success: false, error: 'Failed to update lot status' }
    }

    // Send notification
    await supabaseAdmin.from('notifications').insert({
      user_id: lot.seller_id,
      type: 'deposit',
      title: '保证金退款已完成',
      content: `您的保证金退款已完成，退款金额为 ${refundedAmount.toFixed(2)} ${lot.currency}（已扣除手续费 ${refundFeeAmount.toFixed(2)} ${lot.currency}）。`,
      related_id: lot.id,
      related_type: 'deposit_lot',
      link: `/seller/deposit`,
    }).catch((err) => {
      console.error('Failed to send notification:', err)
    })

    return {
      success: true,
      transactionId: refundTransactionId,
    }
  } catch (error: any) {
    console.error('processDepositRefund error:', error)
    return { success: false, error: error.message || 'Failed to process refund' }
  }
}
```

**测试要点**：
- Stripe 退款应正确执行
- 手续费应正确计算
- lot 状态应更新为 `refunded`
- 退款交易记录应正确创建
- 通知应发送给卖家

---

#### 任务 T7：创建保证金退款前端页面（P2，可选）

**目标**：创建前端页面，允许卖家查看和申请保证金退款。

**涉及文件**：
- 新建：`src/app/[locale]/(main)/seller/deposit/refund/page.tsx`

**实施步骤**：

1. **创建退款页面**
   - 显示所有 `refundable` 和 `refunding` 状态的 lot
   - 对于 `refundable` 且 `refundable_at <= NOW()` 的 lot，显示"申请退款"按钮
   - 对于 `refunding` 状态的 lot，显示"处理中"
   - 对于 `refunded` 状态的 lot，显示退款详情

2. **集成退款申请 API**
   - 调用 `POST /api/deposits/[lotId]/request-refund`
   - 处理成功/失败反馈

**功能要点**：
- 列表展示所有可退款/已退款的 lot
- 申请退款按钮（仅对符合条件的 lot）
- 退款状态和进度显示
- 退款金额和手续费说明

---

### 阶段四：测试与文档（P0）

#### 任务 T8：测试与文档更新

**目标**：全面测试所有功能，更新相关文档。

**测试清单**：

1. **订单完成后的自动恢复**
   - [ ] 订单完成后，unfilled 下降至档位以下，`payment_enabled` 自动恢复
   - [ ] 订单完成后，unfilled 仍高于档位，不恢复
   - [ ] 错误不影响订单完成流程

2. **订单取消后的自动恢复**
   - [ ] 单商品订单取消后，卖家接单功能自动恢复（如果满足条件）
   - [ ] 多商品订单取消后，所有相关卖家都检查恢复
   - [ ] 退款失败时，仍应检查恢复

3. **held → refundable 状态流转**
   - [ ] Cron 任务正确调用数据库函数
   - [ ] 符合条件的 lot 状态正确更新
   - [ ] `refundable_at` 时间戳正确设置

4. **保证金退款申请**
   - [ ] 只有 lot 所有者可以申请
   - [ ] 只有符合条件的 lot 可以申请
   - [ ] 状态正确更新为 `refunding`

5. **保证金退款处理**
   - [ ] Stripe 退款正确执行
   - [ ] 手续费正确计算
   - [ ] lot 状态正确更新
   - [ ] 通知正确发送

**文档更新**：
- 更新 `docs/subscription-system-analysis.md`，标记已修复的缺口
- 更新 API 文档（如有）
- 更新用户文档（保证金退款流程）

---

## 四、实施时间表

### 第一周：核心功能修复（P0）
- **Day 1-2**：任务 T1（订单完成后的自动恢复）
- **Day 3-4**：任务 T2（订单取消后的自动恢复）
- **Day 5**：任务 T8 部分测试（T1、T2）

### 第二周：状态流转实现（P1）
- **Day 1-3**：任务 T3（数据库函数）
- **Day 4**：任务 T4（Cron 任务）
- **Day 5**：任务 T8 部分测试（T3、T4）

### 第三周：退款流程实现（P1）
- **Day 1-3**：任务 T5（退款申请 API）
- **Day 4-5**：任务 T6（退款处理逻辑）

### 第四周：前端与收尾（P2 + P0）
- **Day 1-3**：任务 T7（前端页面，可选）
- **Day 4-5**：任务 T8（完整测试与文档）

**总计**：约 4 周（20 个工作日）

---

## 五、风险评估与应对

### 5.1 技术风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|---------|
| 数据库函数性能问题 | 中 | 低 | 添加索引，优化查询 |
| Cron 任务执行失败 | 中 | 中 | 添加重试机制，监控告警 |
| 退款 API 调用失败 | 高 | 低 | 实现重试和回滚机制 |
| 并发问题（多订单同时完成） | 中 | 中 | 使用数据库锁，确保原子性 |

### 5.2 业务风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|---------|---------|
| 退款金额计算错误 | 高 | 低 | 充分测试，代码审查 |
| 自动恢复误触发 | 中 | 低 | 严格验证条件，添加日志 |
| 用户投诉（退款延迟） | 中 | 中 | 明确退款时间，及时通知 |

---

## 六、验收标准

### 6.1 功能验收

- [x] 订单完成/取消后，系统自动检查并恢复卖家接单功能
- [x] 保证金 lot 在满足条件后自动变为 `refundable` 状态
- [x] 卖家可以申请保证金退款
- [x] 平台可以处理保证金退款（Stripe 支付方式）
- [x] 所有状态流转都有日志记录

### 6.2 性能验收

- Cron 任务执行时间 < 30 秒（1000 个 lot）
- API 响应时间 < 2 秒
- 数据库查询优化，无慢查询

### 6.3 质量验收

- 代码通过 ESLint 检查
- 所有关键路径有错误处理
- 有完整的日志记录
- 文档已更新

---

## 七、后续优化建议

### 7.1 短期优化（1-2 个月）

1. **工作日计算优化**
   - 实现严格的工作日计算（排除周末和节假日）
   - 使用配置文件管理节假日

2. **退款方式扩展**
   - 支持 PayPal 退款
   - 支持其他支付方式的退款

3. **监控与告警**
   - 添加 Cron 任务执行监控
   - 添加退款失败告警

### 7.2 长期优化（3-6 个月）

1. **自动化退款处理**
   - 创建自动处理 `refunding` 状态的 Cron 任务
   - 减少人工干预

2. **退款历史与统计**
   - 添加退款历史查询 API
   - 添加退款统计报表

3. **用户体验优化**
   - 退款进度实时显示
   - 退款到账通知

---

## 八、附录

### 8.1 相关文件清单

**数据库迁移**：
- `supabase/migrations/115_create_seller_deposit_lots.sql`
- `supabase/migrations/127_create_deposit_check_with_side_effects.sql`
- `supabase/migrations/128_fix_deposit_currency_conversion.sql`
- `supabase/migrations/129_cleanup_invalid_deposit_lots.sql`
- `supabase/migrations/138_update_deposit_lots_to_refundable.sql`（新建）

**业务逻辑**：
- `src/lib/deposits/payment-control.ts`
- `src/lib/orders/auto-recovery.ts`
- `src/lib/deposits/process-deposit-refund.ts`（新建）

**API 路由**：
- `src/app/api/orders/[id]/confirm-receipt/route.ts`
- `src/app/api/orders/[id]/cancel/route.ts`
- `src/app/api/deposits/[lotId]/request-refund/route.ts`（新建）
- `src/app/api/admin/deposits/[lotId]/process-refund/route.ts`（新建）
- `src/app/api/cron/update-deposit-lots-status/route.ts`（新建）

**前端页面**：
- `src/app/[locale]/(main)/seller/deposit/refund/page.tsx`（新建，可选）

**配置文件**：
- `vercel.json`

### 8.2 数据库函数清单

- `check_deposit_refundable(p_deposit_lot_id UUID)` - 检查 lot 是否可退款
- `update_deposit_lots_to_refundable()` - 更新 lot 状态为 refundable（新建）
- `checkAutoRecovery(seller_id)` - 检查并恢复卖家接单
- `enable_seller_payment(seller_id)` - 启用卖家支付功能

### 8.3 关键状态流转

```
订单完成/取消
  ↓
unfilled 下降
  ↓
checkAutoRecovery
  ↓
payment_enabled = true（如果 unfilled <= tier）

held lot
  ↓
check_deposit_refundable = true
  ↓
status = 'refundable'
refundable_at = NOW() + 3 days
  ↓
卖家申请退款
  ↓
status = 'refunding'
  ↓
平台处理退款
  ↓
status = 'refunded'
```

---

## 九、总结

本实施计划基于《订阅-订单-保证金全链路分析报告》中识别的三个关键缺口，制定了详细的修复方案。计划分为四个阶段，预计 4 周完成。所有任务都有明确的优先级、实施步骤和验收标准。

**关键成功因素**：
1. 严格按照优先级执行（P0 → P1 → P2）
2. 每个任务完成后立即测试
3. 保持代码质量和文档同步更新
4. 充分测试边界情况和错误处理

**预期收益**：
- 完善保证金生命周期管理
- 提升卖家体验（自动恢复接单）
- 实现保证金退款的完整闭环
- 减少人工干预，提高系统自动化程度
