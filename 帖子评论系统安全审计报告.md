# 帖子评论系统安全审计报告

**审计时间**: 2026-01-26  
**审计范围**: 帖子详情页评论系统完整链路  
**审计人员**: 系统审计员（模拟真实用户视角）

---

## 执行摘要

本次审计从真实用户视角出发，对帖子评论系统进行了端到端的推演和检查。共发现 **🔴 严重问题 8 项**、**🟠 中等问题 6 项**、**🟢 可优化项 4 项**。

**核心风险**：
1. 数据库层面缺少嵌套深度约束，可通过 API 绕过前端限制创建超过 2 层的嵌套评论
2. 缺少跨 post 回复验证，可能构造跨帖子回复
3. 删除评论时未级联处理子评论，导致数据不一致
4. 缺少 XSS 防护和内容 sanitization
5. 缺少批量刷评论的 rate limit 保护

---

## 一、页面初始化阶段

### ✅ 正常点

1. **帖子数据加载**
   - 使用 `usePost` hook 进行客户端查询
   - 错误处理完善，区分不同类型的错误（不存在/权限/网络）

2. **评论列表加载**
   - 使用 React Query 进行数据获取和缓存
   - 实时订阅机制（Supabase Realtime）确保评论更新

### 🔴 P0-1: 评论查询缺少分页，存在性能风险

**问题描述**：
- 评论查询一次性拉取所有评论（`.order('created_at', { ascending: true })`）
- 没有分页机制，对于评论数较多的帖子（如 1000+ 条），会导致：
  - 首次加载时间长
  - 内存占用高
  - 网络传输数据量大

**触发路径**：
- 用户访问评论数 > 100 的帖子详情页

**涉及模块**：
- `src/components/social/CommentSection.tsx:128-145`
- `supabase/migrations/001_initial_schema.sql:207-215`

**修复建议**：
- 实现分页查询（如每页 20-50 条）
- 使用 `useInfiniteQuery` 实现无限滚动
- 添加评论总数显示，支持跳转到指定页

---

### 🔴 P0-2: 未检查帖子是否允许评论

**问题描述**：
- 评论查询和提交时，未验证帖子状态（是否被删除、下架、私有）
- 未检查帖子作者是否禁用了评论功能（如果存在此功能）
- 未检查当前用户是否被帖子作者拉黑

**触发路径**：
- 用户访问已删除/下架的帖子，仍能看到评论框
- 用户尝试评论被拉黑用户的帖子

**涉及模块**：
- `src/components/social/CommentSection.tsx:172-286`
- `src/app/[locale]/(main)/post/[id]/page.tsx:29-98`

**修复建议**：
- 在 `addCommentMutation` 中验证 `post_id` 是否存在且状态为 `approved`
- 检查帖子作者是否拉黑了当前用户
- 前端根据帖子状态和用户关系隐藏/禁用评论框

---

### 🟠 P1-1: 未检查用户是否被禁言

**问题描述**：
- 评论提交时，未检查用户是否被禁言（`profiles.status = 'banned'` 或 `'suspended'`）
- 虽然 RLS 策略在 `153_add_user_status_field.sql` 中限制了被禁用户创建评论，但前端未提前检查，导致用户体验差

**触发路径**：
- 被禁言用户尝试发表评论，提交后才收到错误提示

**涉及模块**：
- `src/components/social/CommentSection.tsx:172-286`
- `supabase/migrations/153_add_user_status_field.sql:115-127`

**修复建议**：
- 在评论提交前检查 `user.status`，如果被禁言，提前提示用户
- 在评论框上方显示禁言提示（如果用户被禁言）

---

## 二、发表评论（一级评论）推演

### ✅ 正常点

1. **输入框状态**
   - 未登录用户无法看到评论输入框（`{user && ...}`）
   - 提交中禁用重复提交（`disabled={addCommentMutation.isPending}`）
   - 内容为空时禁用提交按钮

2. **Optimistic UI**
   - 实现了乐观更新，评论立即显示在列表中
   - 错误时回滚状态

### 🔴 P0-3: 缺少 XSS 防护和内容 Sanitization

**问题描述**：
- 评论内容直接渲染到 DOM（`<p className="text-sm text-muted-foreground mt-1 break-words">{comment.content}</p>`）
- 未对用户输入进行 HTML 转义或 sanitization
- 存在 XSS 注入风险

**触发路径**：
- 用户提交包含恶意脚本的评论：`<script>alert('XSS')</script>`
- 或包含 HTML 标签：`<img src=x onerror="alert('XSS')">`

**涉及模块**：
- `src/components/social/CommentSection.tsx:957`
- `src/components/social/CommentSection.tsx:203-220`（插入时未 sanitize）

**修复建议**：
- 使用 `DOMPurify` 或类似库对评论内容进行 sanitization
- 或使用 React 的自动转义（但需要确保所有渲染路径都使用 React）
- 在插入数据库前进行 sanitization，存储时保留原始内容但渲染时 sanitize

---

### 🔴 P0-4: 缺少批量刷评论的 Rate Limit

**问题描述**：
- 虽然 `047_add_basic_rate_limits.sql` 中可能有 rate limit，但评论提交时未检查
- 前端没有防抖/节流机制
- 可以快速连续提交多条评论，可能导致：
  - 数据库压力
  - 通知风暴
  - 恶意刷屏

**触发路径**：
- 用户快速连续点击提交按钮
- 使用脚本批量提交评论

**涉及模块**：
- `src/components/social/CommentSection.tsx:172-286`
- `supabase/migrations/047_add_basic_rate_limits.sql`

**修复建议**：
- 前端添加防抖机制（如 2 秒内只能提交一次）
- 后端 API 添加 rate limit（如每分钟最多 10 条评论）
- 使用数据库触发器或函数实现 rate limit

---

### 🟠 P1-2: 评论数更新可能不同步

**问题描述**：
- 乐观更新中，评论数立即 +1（`queryClient.setQueryData(['post', postId], ...)`）
- 但实际数据库更新可能失败，导致 UI 显示错误
- 如果多个用户同时评论，可能出现计数不一致

**触发路径**：
- 用户 A 和用户 B 同时评论同一帖子
- 乐观更新导致计数 +2，但实际可能只插入 1 条（如果存在并发问题）

**涉及模块**：
- `src/components/social/CommentSection.tsx:249-255`
- `src/components/social/CommentSection.tsx:271-272`

**修复建议**：
- 使用数据库触发器自动更新 `posts.comment_count`
- 在 `onSuccess` 中重新查询帖子数据，确保计数准确
- 考虑使用原子操作（如 `UPDATE posts SET comment_count = comment_count + 1`）

---

### 🟢 P2-1: 评论内容长度限制提示不明确

**问题描述**：
- 评论内容限制 500 字符，但输入框未显示剩余字符数
- 用户不知道还能输入多少字符

**触发路径**：
- 用户输入长评论，超过 500 字符后提交失败

**涉及模块**：
- `src/components/social/CommentSection.tsx:552-560`

**修复建议**：
- 在输入框下方显示字符计数（如 "已输入 450/500 字符"）
- 接近限制时显示警告（如超过 450 字符时变红）

---

## 三、回复评论（二级评论）推演（高风险区）

### ✅ 正常点

1. **UI 限制**
   - 前端通过 `depth` 参数限制只显示 2 层嵌套（`depth === 0` 显示回复，`depth >= 1` 不显示）
   - 回复按钮只在 `depth === 0` 时显示

### 🔴 P0-5: 数据库层面缺少嵌套深度约束

**问题描述**：
- 前端通过 `depth` 限制只显示 2 层，但**数据库层面没有约束**
- 可以通过直接调用 Supabase API 或修改前端代码，创建超过 2 层的嵌套评论
- 例如：创建 `parent_id` 指向二级评论的评论（三级嵌套）

**触发路径**：
```javascript
// 恶意用户可以直接调用
await supabase.from('comments').insert({
  post_id: 'xxx',
  user_id: 'yyy',
  content: '三级嵌套评论',
  parent_id: '二级评论的ID' // 这个二级评论本身已经有 parent_id
})
```

**涉及模块**：
- `supabase/migrations/001_initial_schema.sql:207-215`（comments 表定义）
- `src/components/social/CommentSection.tsx:203-220`（插入逻辑）

**修复建议**：
- 创建数据库函数/触发器，在插入前检查嵌套深度
- 使用递归 CTE 查询 `parent_id` 链，确保不超过 2 层
- 或添加 `depth` 字段，通过触发器自动计算并限制最大深度

**示例修复**：
```sql
-- 创建检查嵌套深度的函数
CREATE OR REPLACE FUNCTION check_comment_depth()
RETURNS TRIGGER AS $$
DECLARE
  current_depth INT := 0;
  current_parent_id UUID := NEW.parent_id;
BEGIN
  -- 如果有 parent_id，计算深度
  WHILE current_parent_id IS NOT NULL LOOP
    current_depth := current_depth + 1;
    IF current_depth >= 2 THEN
      RAISE EXCEPTION '评论嵌套深度不能超过 2 层';
    END IF;
    SELECT parent_id INTO current_parent_id
    FROM comments
    WHERE id = current_parent_id;
  END LOOP;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
CREATE TRIGGER check_comment_depth_trigger
BEFORE INSERT ON comments
FOR EACH ROW
EXECUTE FUNCTION check_comment_depth();
```

---

### 🔴 P0-6: 缺少跨 post 回复验证

**问题描述**：
- 插入回复时，未验证 `parent_id` 对应的评论是否属于同一个 `post_id`
- 恶意用户可能构造跨帖子回复，例如：
  - 帖子 A 的评论 ID 是 `comment-123`
  - 在帖子 B 中回复，设置 `parent_id = 'comment-123'`
  - 导致数据不一致和显示错误

**触发路径**：
```javascript
// 恶意用户构造跨帖子回复
await supabase.from('comments').insert({
  post_id: 'post-B',
  user_id: 'user-xxx',
  content: '跨帖子回复',
  parent_id: 'comment-from-post-A' // 这个评论属于 post-A
})
```

**涉及模块**：
- `src/components/social/CommentSection.tsx:203-220`
- `supabase/migrations/001_initial_schema.sql:207-215`

**修复建议**：
- 在插入前验证 `parent_id` 对应的评论的 `post_id` 是否与当前 `post_id` 一致
- 使用数据库触发器或 CHECK 约束实现
- 前端在提交前也进行验证（但后端必须作为最终防线）

**示例修复**：
```sql
-- 在插入前验证 parent_id 的 post_id
CREATE OR REPLACE FUNCTION validate_comment_parent()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.parent_id IS NOT NULL THEN
    IF NOT EXISTS (
      SELECT 1 FROM comments
      WHERE id = NEW.parent_id
      AND post_id = NEW.post_id
    ) THEN
      RAISE EXCEPTION '父评论必须属于同一个帖子';
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_comment_parent_trigger
BEFORE INSERT ON comments
FOR EACH ROW
EXECUTE FUNCTION validate_comment_parent();
```

---

### 🔴 P0-7: 删除评论时未级联处理子评论

**问题描述**：
- 删除评论时，只删除当前评论（`.delete().eq('id', commentId)`）
- 如果该评论有子评论（回复），子评论会变成"孤儿评论"（`parent_id` 指向不存在的评论）
- 虽然数据库有 `ON DELETE CASCADE`，但这是针对外键的，不会自动删除子评论

**触发路径**：
- 用户删除一条有 10 条回复的一级评论
- 10 条回复仍然存在，但 `parent_id` 指向已删除的评论
- 导致数据不一致和显示错误

**涉及模块**：
- `src/components/social/CommentSection.tsx:289-306`
- `supabase/migrations/001_initial_schema.sql:212`（`parent_id UUID REFERENCES comments(id) ON DELETE CASCADE`）

**修复建议**：
- 方案 1：使用软删除，标记 `status = 'deleted'`，保留评论但隐藏
- 方案 2：级联删除所有子评论（使用递归 CTE 查找所有子评论）
- 方案 3：将子评论的 `parent_id` 设置为 `NULL`，使其变成一级评论

**示例修复**：
```sql
-- 创建级联删除函数
CREATE OR REPLACE FUNCTION delete_comment_cascade(comment_id_to_delete UUID)
RETURNS void AS $$
DECLARE
  child_comment_id UUID;
BEGIN
  -- 递归删除所有子评论
  FOR child_comment_id IN
    SELECT id FROM comments WHERE parent_id = comment_id_to_delete
  LOOP
    PERFORM delete_comment_cascade(child_comment_id);
  END LOOP;
  
  -- 删除当前评论
  DELETE FROM comments WHERE id = comment_id_to_delete;
END;
$$ LANGUAGE plpgsql;

-- 或使用触发器自动处理
CREATE OR REPLACE FUNCTION handle_comment_delete()
RETURNS TRIGGER AS $$
BEGIN
  -- 将子评论的 parent_id 设置为 NULL（使其变成一级评论）
  UPDATE comments
  SET parent_id = NULL
  WHERE parent_id = OLD.id;
  
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER handle_comment_delete_trigger
AFTER DELETE ON comments
FOR EACH ROW
EXECUTE FUNCTION handle_comment_delete();
```

---

### 🟠 P1-3: 回复通知可能重复

**问题描述**：
- 根据 `025_add_comment_notification_trigger.sql`，回复评论时会通知：
  - 被回复的评论作者（如果被回复的评论作者不是帖子作者）
  - 帖子作者（如果是一级评论）
- 但如果回复的是帖子作者的评论，可能不会发送回复通知（第 45-48 行），但帖子作者仍会收到评论通知
- 逻辑正确，但可能存在边界情况

**触发路径**：
- 用户 A 回复帖子作者 B 的评论
- 根据触发器逻辑，不会发送回复通知（因为被回复的评论作者就是帖子作者）
- 但帖子作者 B 会收到评论通知（因为这是对帖子的评论）

**涉及模块**：
- `supabase/migrations/025_add_comment_notification_trigger.sql:40-48`
- `supabase/migrations/055_optimize_comment_notifications.sql:44-47`

**修复建议**：
- 当前逻辑已正确处理，但可以优化通知内容，明确区分"回复您的评论"和"评论您的帖子"
- 确保通知去重机制（`055_optimize_comment_notifications.sql` 中的 5 秒去重）正常工作

---

## 四、评论互动功能（点赞 / 删除 / 举报）

### ✅ 正常点

1. **点赞评论**
   - 实现了乐观更新
   - 错误时回滚状态
   - 使用唯一约束防止重复点赞（`error.code !== '23505'`）

2. **删除评论**
   - 只有评论作者可以删除（通过 RLS 策略）
   - 有确认对话框防止误删

### 🔴 P0-8: 删除评论权限验证不完整

**问题描述**：
- 删除评论时，只检查前端 `isOwner`（`user?.id === comment.user_id`）
- 虽然 RLS 策略在 `026_add_comment_update_delete_policies.sql` 中限制了只有作者或 admin 可以删除，但：
  - 帖子作者应该也能删除自己帖子下的所有评论（如果业务需求如此）
  - 当前 RLS 策略只允许评论作者删除，未考虑帖子作者权限

**触发路径**：
- 帖子作者想删除自己帖子下的恶意评论，但无法删除（只能举报）

**涉及模块**：
- `src/components/social/CommentSection.tsx:289-306`
- `supabase/migrations/026_add_comment_update_delete_policies.sql:11-16`

**修复建议**：
- 如果业务需求允许帖子作者删除自己帖子下的评论，更新 RLS 策略：
```sql
DROP POLICY IF EXISTS "Users can delete own comments" ON comments;
CREATE POLICY "Users can delete own comments or post authors can delete comments on their posts"
ON comments FOR DELETE
USING (
  auth.uid() = user_id
  OR EXISTS (
    SELECT 1 FROM posts
    WHERE posts.id = comments.post_id
    AND posts.user_id = auth.uid()
  )
  OR EXISTS (
    SELECT 1 FROM profiles
    WHERE profiles.id = auth.uid()
    AND profiles.role IN ('admin', 'support')
  )
);
```

---

### 🟠 P1-4: 点赞并发可能导致计数错误

**问题描述**：
- 虽然使用唯一约束防止重复点赞，但并发场景下可能出现：
  - 用户 A 和用户 B 同时点赞同一条评论
  - 两个请求都通过唯一约束检查（因为检查时都还没有插入）
  - 导致计数可能不准确（虽然不会重复插入，但计数更新可能有问题）

**触发路径**：
- 多个用户同时快速点赞同一条评论

**涉及模块**：
- `src/components/social/CommentSection.tsx:978-1001`（CommentLikeButton）
- `src/components/social/CommentLikeButton.tsx:68-130`

**修复建议**：
- 使用数据库触发器自动更新 `comments.like_count`（类似 `042_add_comment_likes.sql` 中的实现）
- 或使用原子操作（`UPDATE comments SET like_count = like_count + 1`）
- 确保计数更新是原子性的

---

### 🟢 P2-2: 举报功能缺少防重复举报机制

**问题描述**：
- 用户可以重复举报同一条评论
- 虽然可能有数据库唯一约束，但前端未检查用户是否已举报

**触发路径**：
- 用户多次点击举报按钮

**涉及模块**：
- `src/components/social/CommentSection.tsx:510-517`
- `src/components/social/ReportDialog.tsx`

**修复建议**：
- 在提交举报前检查用户是否已举报过该评论
- 如果已举报，显示提示"您已举报过此评论"
- 数据库层面使用唯一约束（`(reporter_id, reported_type, reported_id)`）

---

## 五、评论系统与其他模块的联动

### ✅ 正常点

1. **评论 → 通知中心**
   - 触发器自动创建通知（`025_add_comment_notification_trigger.sql`）
   - 有去重机制（`055_optimize_comment_notifications.sql`）

2. **评论 → 帖子热度**
   - 评论数更新会触发帖子数据刷新（`queryClient.invalidateQueries({ queryKey: ['post', postId] })`）

### 🟠 P1-5: 评论删除后帖子评论数可能不同步

**问题描述**：
- 删除评论后，虽然会 `invalidateQueries`，但：
  - 如果使用数据库触发器自动更新 `posts.comment_count`，删除时应该自动 -1
  - 当前可能没有这样的触发器，导致计数不准确

**触发路径**：
- 用户删除评论后，帖子详情页的评论数未更新

**涉及模块**：
- `src/components/social/CommentSection.tsx:298-301`
- `supabase/migrations/001_initial_schema.sql`（可能缺少评论数更新触发器）

**修复建议**：
- 创建数据库触发器，在评论插入/删除时自动更新 `posts.comment_count`
- 或使用数据库函数计算实时评论数（但可能影响性能）

---

### 🟢 P2-3: 评论作者资料链接缺少权限检查

**问题描述**：
- 点击评论作者头像/用户名，跳转到 `/profile/${comment.user_id}`
- 未检查该用户是否被封禁/暂停，可能导致跳转到无效页面

**触发路径**：
- 用户点击被封禁用户的评论作者链接

**涉及模块**：
- `src/components/social/CommentSection.tsx:810-831`

**修复建议**：
- 在跳转前检查用户状态，如果被封禁，显示提示或禁用链接
- 或在 Profile 页面处理被封禁用户的情况（已有处理）

---

## 六、异常 & 安全视角

### 🔴 P0-9: RLS 策略未验证帖子可见性

**问题描述**：
- 评论的 RLS 策略（`153_add_user_status_field.sql:78-95`）只检查：
  - `status = 'approved'` 且评论作者状态为 `active`
  - 或评论作者是自己
  - 或是 admin/support
- **但未检查帖子本身的可见性**（帖子是否被删除、下架、私有）

**触发路径**：
- 用户访问已删除的帖子，仍能看到该帖子下的评论（如果知道评论 ID）

**涉及模块**：
- `supabase/migrations/153_add_user_status_field.sql:78-95`

**修复建议**：
- 更新 RLS 策略，确保只能查看可见帖子下的评论：
```sql
DROP POLICY IF EXISTS "Users can view approved comments from active users" ON comments;
CREATE POLICY "Users can view approved comments from active users on visible posts"
ON comments FOR SELECT
USING (
  (
    status = 'approved' AND 
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE profiles.id = comments.user_id 
      AND profiles.status = 'active'
    ) AND
    EXISTS (
      SELECT 1 FROM posts
      WHERE posts.id = comments.post_id
      AND posts.status = 'approved'
      -- 可以添加更多帖子可见性检查
    )
  ) OR
  user_id = auth.uid() OR 
  EXISTS (
    SELECT 1 FROM profiles 
    WHERE profiles.id = auth.uid() 
    AND profiles.role IN ('admin', 'support')
  )
);
```

---

### 🔴 P0-10: 缺少评论内容审核机制

**问题描述**：
- 评论插入时，`status` 直接设置为 `'approved'`（`status: 'approved'`）
- 没有内容审核流程，恶意内容会立即显示
- 虽然可能有后端的审核机制，但前端未体现

**触发路径**：
- 用户提交包含敏感内容的评论，立即显示在页面上

**涉及模块**：
- `src/components/social/CommentSection.tsx:211`

**修复建议**：
- 方案 1：新评论默认 `status = 'pending'`，等待审核
- 方案 2：使用内容审核 API（如 AI 审核），自动标记可疑内容
- 方案 3：实现关键词过滤，自动标记或拒绝包含敏感词的评论

---

### 🟠 P1-6: 评论图片上传缺少大小和类型限制

**问题描述**：
- 评论支持上传图片（最多 5 张），但：
  - 未检查图片大小（可能导致存储成本高）
  - 未检查图片类型（虽然 `accept="image/*"`，但可以绕过）
  - 未检查图片内容（可能上传恶意图片）

**触发路径**：
- 用户上传超大图片（如 50MB），导致上传失败或存储成本高
- 用户上传非图片文件（通过修改请求）

**涉及模块**：
- `src/components/social/CommentSection.tsx:572-580`
- `src/lib/hooks/useImageUpload.ts`

**修复建议**：
- 前端检查图片大小（如最大 5MB）
- 后端验证文件类型和大小
- 使用图片处理库压缩图片
- 考虑使用 CDN 存储图片

---

## 修复优先级建议

### P0（立即修复）
1. **P0-5**: 数据库层面缺少嵌套深度约束 ⚠️ **最高优先级**
2. **P0-6**: 缺少跨 post 回复验证 ⚠️ **最高优先级**
3. **P0-3**: 缺少 XSS 防护
4. **P0-7**: 删除评论时未级联处理子评论
5. **P0-9**: RLS 策略未验证帖子可见性
6. **P0-10**: 缺少评论内容审核机制
7. **P0-4**: 缺少批量刷评论的 Rate Limit
8. **P0-8**: 删除评论权限验证不完整

### P1（本周修复）
1. **P1-1**: 未检查用户是否被禁言
2. **P1-2**: 评论数更新可能不同步
3. **P1-3**: 回复通知可能重复（逻辑已正确，但需确认）
4. **P1-4**: 点赞并发可能导致计数错误
5. **P1-5**: 评论删除后帖子评论数可能不同步
6. **P1-6**: 评论图片上传缺少大小和类型限制

### P2（优化项）
1. **P2-1**: 评论内容长度限制提示不明确
2. **P2-2**: 举报功能缺少防重复举报机制
3. **P2-3**: 评论作者资料链接缺少权限检查
4. **P0-1**: 评论查询缺少分页（性能优化）

---

## 总结

本次审计发现评论系统在**数据完整性**和**安全性**方面存在多个严重问题，特别是：

1. **嵌套深度约束**：前端限制可被绕过，必须在数据库层面实现
2. **跨 post 回复验证**：可能导致数据不一致
3. **XSS 防护**：缺少内容 sanitization，存在安全风险
4. **删除级联**：删除评论时未处理子评论，导致数据不一致

建议**优先修复 P0 问题**，特别是数据库层面的约束和验证，这些是系统的最后一道防线。

---

**报告生成时间**: 2026-01-26  
**下次审计建议**: 修复 P0 问题后，进行回归测试和二次审计
